using gold.**
// ===============================
// Proyecto 2 (ISIS1106 - Lenguajes y Máquinas)
// Realizado por:
// Carol Florido - 202111430
// Nicolás Rincón - 202021963
//
// Basado en el trabajo original de Silvia Takahashi
// ===============================

// Finite State Transducer that implements a Coder
// Input: Strings of the form ⍸_1!⍸_2!⍸_3!‥.!⍸_{2n-1}!⍸_{2n}# where ⍸_i∈('a'‥.'d')* of length 3, ∀i:0≤i≤2n
//  		 and the three characters that compose any ⍸_i are not necessarily distinct.

// Output: Strings of the form ρ_1!ρ_2!ρ_3!‥.!ρ_{2n-1}!ρ_{2n}# where ρ_i=⍸_i if i is odd, ρ_i=⍸_i if i is even
//		   and ρ_i≠⍸_{i-1}, and ρ_i="*" if i is even and ρ_i=⍸_{i-1}.
// ===============================

var  Alph 

procedure main(args:String[]) begin
	// Reads the given alphabet or uses a cat basic alphabet for default
	if args.length=0 then Alph:= {'a','c','t'}
	else
		Alph := {args[0].charAt(i) | 0≤i<args[0].length()}\{'$','#'}
    end
	// Create a Transducer object over the alphabet given in the input
	coder:=createTransducer(Alph)
	print "Input strings of the form w_1!w_2!...!w_2n-1!w_2n# with w_i over " + Alph
	// Utilities by default in Gold:
	Utilities.test(coder)
end

// Function that creates a transducer over a given alphabet
function createTransducer(A):ITransducer begin
	// Given the alphabet with letters spanning from 'a' to 'd', A:=('a'‥'d')
	M0 := {true,false} 	// Condition that tests whether we are in an even ⍸_i or not
	M1 := A					// Represents the reading of the first character in an ⍸
	M2 := A×A				// Represents the reading of the first two characters in an ⍸
	M3 := A×A×A			// Represents the reading of the three characters in an ⍸
	Ls := ({false}×M1)∪({false}×M2)∪({false}×M3)	// Initial different states (⍸_1)
	
	// States are created in the following way:
	// In general ([p1,p2,p3],T/F,[c1,c2,c3]) where p_i are the characters of the previous ⍸, that is ⍸_{i-1},
	// c_i are the characters of the current ⍸, that is ⍸_i, and T/F whether i is even or not
	// Exceptions are states associated with ⍸_1 where there are no previous ⍸ to take into account
	// The states also include a Starting State (I) Final State (F) and an Error State (err)
	Q := Ls∪(M3×M0)∪(M3×M0×M1)∪(M3×M0×M2)∪(M3×M0×M3)∪{"err","F","I"}
	print Q
	
	// The input alphabet is A union with separators ("#" and "!")
	Σ := A ∪ {'#','!'}
	// The output alphabet is the input alphabet union with special replacement "*"
	O := Σ ∪ {'*'}
	// The initial state is the one marked as "I"
	q₀ := "I"
	// The final state is the one marked as "F"
	F := {"F"} 
	
	// The transducer is constructed as a 6-tuple with transition function g and output function h
	return GDeterministicTransducer(Q,Σ,O,q₀,F,δ,g,h)
end

// We are designing a Mealy Automaton, so the State Printing Function is null
g(x):= λ

// Transition Function that receives a state and a next-to-read character
function δ(q,σ) begin
	var p1: Object
	var p2: Object
	var p3: Object
	var c1: Object
	var c2: Object
	var c3: Object
	var even: boolean
	
	// The initial states move depending on which character is read
	if q = "I" ∧ σ∈Alph 
		then print q return ⟨false,σ⟩
			
	elseif q = ⟨false,c1⟩ ∧ σ∈Alph 
		then print q return ⟨false,⟨c1,σ⟩⟩
	elseif q = ⟨false,⟨c1,c2⟩⟩ ∧ σ∈Alph 
		then print q return ⟨false,⟨c1,c2,σ⟩⟩
	
	// States that have read a full ⍸ move to specific states in which currents become previous
	// If we read a ! then we change from odd to even or even to odd
	elseif (q = ⟨even,⟨c1,c2,c3⟩⟩ ∨ q = ⟨⟨p1,p2,p3⟩,even,⟨c1,c2,c3⟩⟩) ∧ σ='!'
		then print q return ⟨⟨c1,c2,c3⟩,!even⟩
	// States that are fully-read, even and followed by a # go to the Final State
	elseif q = ⟨⟨p1,p2,p3⟩,even,⟨c1,c2,c3⟩⟩ ∧ even = true ∧ σ='#'
		then print q return "F"
	
	// When we start reading a ⍸, states will go to the next one that has been read
	elseif q = ⟨⟨p1,p2,p3⟩,even⟩ ∧ σ∈Alph 
		then print q return ⟨⟨p1,p2,p3⟩,even,σ⟩
	elseif q = ⟨⟨p1,p2,p3⟩,even,c1⟩ ∧ σ∈Alph 
		then print q return ⟨⟨p1,p2,p3⟩,even,⟨c1,σ⟩⟩
	elseif q = ⟨⟨p1,p2,p3⟩,even,⟨c1,c2⟩⟩ ∧ σ∈Alph 
		then print q return ⟨⟨p1,p2,p3⟩,even,⟨c1,c2,σ⟩⟩		
	
	// If the state is the Final State, anything after it will turn it into an Error
	elseif q = "F" ∧ σ≠λ
		then print q return "err"
	// If the state is the Error State, it will always remain in said state
	elseif q = "err"
		then print q return "err"
	// In any other case, it has to be an error
	else
		print q return "err"
	end
end

// Transition output function that prints during a transition
function h(q,σ) begin
	var p1: String
	var p2: String
	var p3: String
	var c1: String
	var c2: String
	var c3: String
	var even: boolean
	
	// Once a fully-read state has transitioned, it should print the current under the following conditions:
	// c1c2c3 if it is odd or even and p1p2p3≠c1c2c3
	// * if it is even and p1p2p3=c1c2c3
	// In both cases, it must be followed by the symbol ! or #
	if (q = ⟨even,⟨c1,c2,c3⟩⟩ ∨ q = ⟨⟨p1,p2,p3⟩,even,⟨c1,c2,c3⟩⟩) then
		if σ='!' ∧ even = false 
			then return c1+c2+c3+σ
		elseif (σ='!' ∨ σ='#') ∧ even = true then
			if (p1=c1 ∧ p2=c2 ∧ p3=c3) 
				then return '*'+σ
			else
				return c1+c2+c3+σ
			end
		end
	// In any other case, do not print anything (returns the empty string)
	else
		return λ
	end
end


 